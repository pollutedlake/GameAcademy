#pragma once
#include <iostream>

using namespace std;

class MainGame_06;

#pragma region 템플릿 + 클래스 변수 / 함수
/*
▶ 템플릿이란?

- 클래스 또는 함수를 선언할 때 데이터의 타입을 명시하지 않고 클래스 또는 함수를 정의할 수 있는 기능을 의미한다.

- 템플릿을 이용하면 특정 타입에 종속되지 않는 로직을 작성하는 것이 가능하다.

- 일반화 프로그래밍(EX) STL)에 중추적인 역할을 하는 문법
ㄴ 데이터 형식에 상관없이 로직을 구현하는 것을 의미한다.

▷ 템플릿 요약

- 컴파일러가 미리 등록된 함수의 틀을 기억해 두었다가 함수가 호출될 때 실제 함수를 만드는 장치라고도 할 수 있다. (이는 클래스에도 동일하게 적용된다.)

◈ 템플릿
ㄴ 여러가지 함수, 클래스를 찍어내는 틀
ㄴ 템플릿의 종류에는 함수 템플릿과 클래스 템플릿이 있다.

1. 함수 템플릿

- 함수 위에 템플릿을 선언한 것을 의미한다.
ㄴ 함수 템플릿은 함수마다 선언을 해줘야 한다.

EX)
template <typename T> T Function()
{
	T........;
}

2. 클래스 템플릿
ㄴ 클래스 위에 템플릿 선언
ㄴ 클래스 템플릿은 선언의 type 부분에 class를 명시해 줘야 한다.

EX)
template<class T1>
template<template<typename, typename> class Container>

▷ 템플릿의 특징

- 템플릿만 정의하고 함수를 호출하지 않으면 아무런 일도 일어나지 않는다.
ㄴ 템플릿 자체는 메모리를 소모하지 않는다.

- 호출에 의해 템플릿이 구체화 되어 실체 함수가 될때만 프로그램의 크기가 늘어난다.

- 컴파일러가 컴파일 도중에 각 템플릿 인스턴스에 대한 코드를 생성시켜 준다.

- 템플릿은 헤더 파일 구현을 원칙으로 한다.

▷ 헤더파일에 함수를 직접 구현하는 경우

1. 캡슐화 (접근자, 설정자)
ㄴ C++은 객체지향 언어 -> 캡슐화는 OOP 특징중 1개 -> 캡슐화를 위한 헤더파일 구현 원칙

2. 템플릿
- .h / .cpp로 구분지어 코드를 구현은 가능하다.
ㄴ 하지만 헤더파일에 구현하는걸 권장한다.
ㄴ 이는 컴파일 순서에 의한 처리 때문이며 보통 상속 구조를 가지고 있다면 컴파일러가 에러를 발생 시킨다.

3. 인라인

- 무거운 함수 구조나 연산이 많은 로직이 구현된 함수는 시간의 문제일뿐 언젠가는 반드시 스택 오버 플로우가 발생할 여지를 지니고 있다.

- 이를 해결하기 위해 함수를 인라인화 시킴으로 실행속도 향상을 얻을 수 있다.
ㄴ 함수를 호출하면 스택의 할당과 반환이라는 과정이 발생 하는데 인라인화가 된 함수는 이러한 과정을 전혀 거치지 않는다.

▷ 인라인 키워드 특징

- 적용을 하면 좋은 사례는 몇가지가 있다.

1. 간결한 코드에 적용하면 좋다.

- 인라인 이라는 키워드는 어디까지나 컴파일러에게 명시적으로 알려주는 키워드일뿐 컴파일러가 함수를 인라인화 시킬것인지 아닌지는 결국 컴파일러 마음

- 반대로 인라인 키워드를 붙이지 않았다고 해도 컴파일러가 인라인화 시키는 경우도 있다.

※ 인라인 함수가 왜 필요한지에 대한 이해를 하려면 매크로에 대한 장점/단점에 대해 알고 있으면 좋다.

※ 매크로 함수는 자료형에 독립적이다.

EX)
#define ADD(x)		((x) * (x))		-> x로 올 수 있는 자료형은 자유롭다.

- 인라인으로 선언된 함수를 위의 형태로 정의하려면 각 자료형 타입에 맞는 함수가 오버로딩이 선행되야 한다.

- 매그로 함수와 달리 함수는 자료형에 독립적이지 못한다.

- 이러한 인라인 함수를 자료형에 독립적으로 선언할 수 있게 만들어 주는게 바로 "템플릿"

▷ 컴파일 타임 + 런 타임

★ 처리 단계

- 소스 파일 병합 -> 선행 처리기 -> 전처리기 -> 어셈블리 -> 컴파일러 활동 -> 오브젝트 파일 분할(컴파일 과정 끝 + 템플릿 자료형 확정)			- 컴파일 타임
-> 시동코드와 표준 라이브러리 파일 병합 -> 링커에 의한 obj 링크 -> 실행 -> 컴파일러 재등장													- 런타임

* 컴파일 타임

- 개발자는 프로그램을 생성하기 위해서 컴파일이라는 과정을 통해 기계어 코드로 변환된 실행 가능 프로그램이라는 결과물을 얻을 수 있다.
ㄴ 이러한 편집과정을 컴파일 타임이라고 부른다.

- 기본적으로 컴파일 타임 에러는 프로그램이 성공적으로 컴파일링 되는 것을 방해하는 오류가 있다는 뜻이다.

- 대표적으로 syntax 에러 + 파일 참조 오류가 있다.

- 위와 같은 오류는 컴파일 단계에서 발생하는 일반적인 오류이기 때문에 문제가 발생하면
컴파일러가 문제가 발생한 라인을 지시해 준다.

*  런타임
 
- 컴파일 과정을 마친 프로그램은 사용자에 의해 실행이 되며 이러한 응용프로그램의 동작 시간을 런타임이라고 할 수 있다.

- 소스 코드가 이미 실행 가능한 프로그램으로 컴파일 되었다고 가정을 하더라도 이것은 여전히 버그가 발생할 수 있는 여지를 가지고 있다.

- 이때 컴파일러의 도움을 받을 수 없기 때문에 링커는 일반적으로 프로그램된 오류 메세지를 출력하면서 오류처리를 해버린다.

EX) NULL 참조 오류 / 메모리 부족 등등...

▶ 클래스 변수 / 함수란?

- 일반적으로 클래스의 멤버 변수/함수는 객체를 생성 후 이를 사용하는 것이 가능한 반면 클래스 변수/함수 객체를 생성하지 않더라도 변수와 함수를 사용하는 것이 가능하다.
*/
#pragma endregion

class MainGame_07
{
private:
	int m_nNumber;
public:
	// 일반 함수
	void outPutValue();
	void outPutValue(int num);

	// 템플릿 함수
	template <typename T> void outPutFunc(T num);
	template <typename T1, typename T2> void outPutFunc(T1 numL, T2 numR);

	template < typename T3> T3 maxValue(T3 numL, T3 numR);
	template < typename T4> T4 addValue(T4 numL, T4 numR);
	template < typename T5> T5 riskValue(T5 numL, T5 numR);

	template<typename T>
	void Swap(T& a_rtLhs, T& a_rtRhs)
	{
		T tTemp = a_rtLhs;
		a_rtLhs = a_rtRhs;
		a_rtRhs = tTemp;
	}

	/*
	- C++ 언어의 템플릿 함수 또는 클래스는 기본적으로 모든 데이터 타입에 동작하도록 로직을 작성하는게 원칙이지만 특정 데이터 타입에 동작하도록 로직을 구성하는게 불가능하다면 해당 타입에 동작하도록 로직을 별도로
	구성하는 것을 지원한다.

	- 이를 템플릿 특수화라고 한다.
	*/

	template<>
	void Swap(std::string& a_rtLhs, std::string& a_rtRhs)
	{
		std::string oTemp = a_rtLhs;
		a_rtLhs = a_rtRhs;
		a_rtRhs = oTemp;

		cout << "템플릿 특수화 함수 호출!" << endl;
	}

	template<typename T>
	void minus(T& a_rtLhs, T& a_rtRhs)
	{
		cout << a_rtLhs - a_rtRhs << endl;
	}

	MainGame_07();
	~MainGame_07();
};

// 템플릿 함수를 일반적으로 구현하는 방법
/*template <typename T>
inline void MainGame_07::outPutFunc(T num)
{

}

template <typename T1, typename T2>
inline void MainGame_07::outPutFunc(T1 numL, T2 numR);
*/