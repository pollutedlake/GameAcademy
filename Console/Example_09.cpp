#include<iostream>
//#include "Debug\Console.tlog\.."

using namespace std;

#pragma region 전처리기
/*
▶ 전처리기

- 실행 파일을 생성하는 과정에서 컴파일하기 직전, 소스 파일내에 존재하는 선행 처리 지시문을 처리하는 작업을 의미한다.

- 전처리기가 실행되면 각 코드 파일에서 지시자를 찾기 시작한다.
ㄴ 지시자는 #으로 시작으로 줄 바꿈으로 끝나는 코드

※ 선행 처리를 위한 명령에는 맨 앞에 #기호가 붙는다는 공통점이 있다.

▷ C/C++ 코드를 실행하는 과정

- 순서 : 전처리기 -> 컴파일러 -> 어셈블러 -> 링커

전처리기(Preprocessor)
ㄴ 헤더 파일 삽입, 코드의 주석 제거, 문법 검토, 매크로등을 치환(바꾸다)하는 역할을 수행한다.

컴파일러

어셈블러
ㄴ 어셈블리 코드를 기계어(0 or 1) 변환하여 오브젝트 파일을 생성한다.

링커
ㄴ 각각의 오브젝트 파일들을 묶어서 실행 코드 파일로 변환을 해준다.

- 좀더 쉽게

1. 내가 작성한 소스파일은 먼저 소스파일 처리를 하는 선행 처리를 거치고
2. 컴파일 되어
3. 오브젝트 파일이 생성되고
4. 링커에 의한 실행파일이 된다.

- 더 쉽게
ㄴ [소스 코드] -> [바이너리] -> [실행 파일]

※ 바이너리 : 컴파일러의 의해 생성된 목적 파일

▶ 선행처리를 위한 명령
- 전처리문 = 전처리기 연산자

- 파일 처리를 위한 전처리기문

-> 최적화
1. #include
ㄴ #include <파일 이름> -> 미리 정의된 include폴더에서 파일을 찾는다.
ㄴ #include "사용자 정의 파일 이름" -> 현재의 소스 코드가 저장되어 있는 폴더에서 먼저 찾고 파일이 없다면 미리 정의된 include 폴더에서 파일을 찾는다.

- 형태 정의를 위한 전처리기 문

★ 면접 사골
1. #define
ㄴ #define 키워드는 매크로 상수 또는 매크로 함수를 정의하는 역할을 한다.
매크로 VS 상수
상수가 압도적으로 효율이 좋다. 컴파일 시간 메모리 사용량

2. #undef

- 매크로 해제

3. 조건부 컴파일을 위한 전처리기문

- #if, #ifdef, #ifndef, #else, #elif, #endif

ㄴ #ifdef : 식별자가 정의되어 있으면 참
ㄴ #ifcdef : 식별자가 정의되어 있지 않으면 참
ㄴ #endif : 전처리기 부분을 종료 (#if 시리즈)

★ 코드 설계 단계에서 적용을 잘 하면 실행 속도에 매우 큰 이득을 얻을 수 있다.
ㄴ 선택적 컴파일 기법

▶ pragma

- 컴파일러의 기능을 확장시킬 수 있게 나온 문법이며 어떤 동작을 정해주기 위해 사용한다.

※ 컴파일러의 버전에 따라 동작 여부가 결정된다.
ㄴ 덤으로 OS에 따라서도 동작 여부가 결정된다.

#prgma region 이름
- 코드를 개요, 축소가 가능하게 묶는다.
#pragma endregion

#pragma once
ㄴ 헤더 파일 중복 방지
ㄴ 링크할 때 헤더 파일이 한번만 포함하게 된다.

#pragma message("Example_07.cpp 절대 수정하지 말것)
ㄴ 컴파일시 출력창에 메세지 출력
ㄴ 주로 협업시 개발자에게 경고를 알려줄때 사용한다.
*/
#pragma endregion	전처리기 재밌다

#pragma region 매크로 상수
/*
▶ 매크로 상수를 정의 할 때 주의점

1. #define문은 코드를 생성하는 명령이 아니며 매크로의 이름도 일종의 명칭이기 때문에 명칭 규칙에 맞게 작성해야 한다.

※ 매크로의 표기법은 대문자 표기법을 쓴다.
ㄴ 띄어쓰기는 _언더바로 표기한다 -> 스네이크

2. 매크로 이름에는 공백이 들어갈 수 없지만 매크로 실제 값을 공백을 가질 수 있다.
ㄴ EX) #define MSG "똑바로 공부하자"

3. 문자열 상수내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않는다.

4. 매크로는 중첩 가능
EX) #define A 3
EX) #define B (A * 3)

5. 값을 가지지 않는 빈 매크로도 정의 가능
ㄴ EX) #define AAA
ㄴ 위 매크로를 해석하면 값을 가지고 있지 않으며 매크로 상수 자체만 존재한다.

6. 매크로 상수는 단순히 컴파일전에 코드를 튜닝하기 위한 전처리기에 의해서 처리되는 상수이기 때문에 컴파일러 입장에서는 리터널 상수와 동일시 된다.
ㄴ 리터널 상수와 동일시 -> 컴파일러는 매크로 상수의 존재를 알 수 없다.
*/
#pragma endregion

#pragma message("Example_07.cpp 절대 수정하지 말것")

// 매크로 표기법
// ㄴ 상수의 이름은 모두 대문자 -> 스네이크 표기법

// 매크로 정의 방법
// ㄴ #define 매크로명 실제값

#define EXAMPLE_1	1
#define EXAMPLE_2	1

#undef EXAMPLE_2
#define EXAMPLE_2	2

#define TRUE	1
#define FALSE	0

// 매크로 함수 : 함수가 호출되면 스택에 들어가는데 간단한 함수는 매크로 함수로 만들어 스택에 영향을 주지 않겠다.
#define ADD(a) ((a) * (a))

void GetMultipleValue(int numA);

void main()
{
	// ! Do Nothing
}

void GetMultipleValue(int numA)
{
	cout << numA * numA << endl;
}