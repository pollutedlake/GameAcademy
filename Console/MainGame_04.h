#pragma once
#include<iostream>

using namespace std;

#pragma region 가상 함수
/*
▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되어 있을 경우 부모 클래스의 참조 또는 포인터를 가지고 자식 클래스의 특정 함수를 실행시키는 매커니즘을 의미한다.

- 가상 함수를 이용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는 것이 가능하다.

▷ 가상 함수 특징

- C++ 클래스의 특성중 하나인 다형성을 지원하기 위해 "virtual" 키워드를 사용한다.

- 부모 클래스내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다. (오버라이딩)

※ 재정의 되지 않았다면 호출시 부모 클래스의 함수가 호출이 되고 재정의되었다면 함수 호출시 자식 클래스의 함수가 호출된다. (가상 함수 테이블)

▷ 다형성?

- 여러가지를 표현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는걸 뜻한다.

▷ 인스턴스?

- 어느 클래스에 속하는 각 객체를 인스턴스라고 한다.

EX)

- 집이라는 클래스를 만들고 내 방이라는 객체를 생성하면 그 클래스의 인스턴스가 생성된다.

※ 함수 오버로딩 + 함수 오버라이딩

*/
#pragma endregion

// 부모
class weapon
{
public:
	virtual void attack() { cout << "무기로 공격" << endl; }
};

class gun : public weapon
{
public:
	void attack() { cout << "총으로 공격" << endl; }
};

class bow : public weapon
{
public:
	void attack() { cout << "활로 공격" << endl; }
};

class AClass
{
public:
	//void myFunc() { cout << "내가 A 클래스" << endl; }
	
	virtual void classFunction() = 0;

	// - 0은 대입이 아닌 명시적으로 몸체를 정의하지 않겠다는 의미
	// - 순수 가상함수로만 만들어진 클래스를 인터페이스라고 부른다.
	// ㄴ 인터페이스는 인스턴스를 생성할 수 없다.

	AClass() {}
	virtual ~AClass() {}

	/*
	▶ 상속 관계에서의 생성과 소멸

	- 상속을 받은 클래스의 생성과 소멸 과정에는 동일한 규칙이 적용된다.
	ㄴ 부모 클래스의 생성자에서 자식 클래스의 생성자 순서로 호출이 되고 소멸자는 자식 클래스의 소멸자가 먼저 호출이 되면서 부모 클래스의 소멸자가 호출이 되는 구조를 가지고 있다.

	- 부모 클래스의 포인터로 자식 클래스를 호출할 때 가상 함수로 정의되어 있지 않은 자식 클래스의 오버라이딩된 함수를 호출하면 부모 클래스의 멤버 함수가 호출이 된다. 이를 "다형성"이라고 했었다.

	- 소멸자도 자식 클래스에서 오버라이딩된 함수라고 볼 수 있기 때문에 만약 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출이 된다.

	- 따라서 소멸자를 가상 함수로 선언하지 않으면 다형성 매커니즘이 동작하지 않기 때문에 자식 클래스의 소멸자는 결코 호출이 되지 않는 불상사가 발생한다.
	ㄴ 이는 곧 메모리 누수 당첨

	- 가상 함수 키워드를 사용했다면 이것은 자식 클래스에서 재정의될 수 있음을 명시한것이기 때문에 포인터의 종류에 상관없이 자식 클래스의 함수가 호출되는 결과를 볼 수 있다. (재정의 되었다면.)

	※ 자식 클래스 소멸자 호출 -> 부모 클래스의 소멸자를 호출하기 위해
	ㄴ 소멸자에서 해제가 필요한 경우 (상속 관계) 소멸자에 가상화를 고민해 봐야한다.
	*/
};


class MainGame_04
{
private:
	// 재생산성 UPUPUPUP
	// 메모리 사용량과 실행속도 상승 자식 클래스는 가상함수테이블이 생성되지 않는다.
	weapon* _gun;
	weapon* _bow;
	weapon* _myWeapon;
public:
	MainGame_04();
	~MainGame_04();
};

